<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">

</head>
<body class="light">
    <div class='markdown-body'><h1>01-module</h1><h2>代码部分</h2><pre><code class="language-c">#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;

MODULE_LICENSE("GPL");
MODULE_AUTHOR("PD");

static int hello_init(void)
{
    printk("hello_init \n");
    return 0;
}
static void hello_exit(void)
{
    printk("hello_exit \n");
    return;
}

module_init(hello_init); //insmod
module_exit(hello_exit);//rmmod</code></pre><p>模块的加载如上述代码所示,其中 <code>MODULE_LICENSE</code> 和 <code>MODULE_AUTHOR</code> 用于说明开源协议和作者,为可选项,建议加上</p><p>printk和printf是用于在Linux系统中输出调试信息的两个函数，它们之间有以下区别</p><ul><li>printk是在内核空间中使用的函数，而printf是在用户空间中使用的函数。</li></ul><ul><li>printk可以输出到系统日志（system log）或控制台（console），以帮助开发人员进行内核级别的调试，而printf通常输出到控制台，以帮助开发人员进行用户空间级别的调试。</li></ul><ul><li>printk函数具有八个不同的日志级别（log level），可以根据不同的调试需求选择不同的日志级别，从而控制信息的显示和过滤。而printf函数没有这种灵活性，无法按照日志级别控制输出。</li></ul><ul><li>由于printk是在内核空间中使用的函数，因此需要小心使用，避免在过多输出调试信息时导致系统资源的浪费和性能问题。相比之下，printf可以更自由地使用，因为用户空间相对于内核空间更加容错。</li></ul><p>printk和printf有着不同的使用场景和特点，可以根据需要灵活使用。如果需要在内核空间中进行调试，则应该使用printk；如果需要在用户空间中进行调试，则应该使用printf. 我们的驱动代码运行在内核态,均使用printk进行日志记录</p><p>最后将对应函数绑定到模块进入和推出</p><pre><code class="language-Makefile">ifneq ($(KERNELRELEASE),)
obj-m:=hello.o
else
KDIR :=/lib/modules/$(shell uname -r)/build
PWD  :=$(shell pwd)
all:
    make -C $(KDIR) M=$(PWD) modules
clean:
    rm -f *.ko *.o *.mod.o *.symvers *.cmd  *.mod.c *.order
endif</code></pre><p>Makefile文件一共执行三次,第一次 <code>KERNELRELEASE</code> 宏为false,执行else</p><p><code>uname -r</code> 的返回值为linux内核路径的文件夹名字,接着进入该路径执行linux内核的modules目标,M带入当前路径</p><p>第二次进入使用gcc生成hello.o</p><p>第三次进入生成其余文件,其中 <code>hello.ko</code>(kernel object) 为模块文件</p><h2>运行</h2><p>在运行的时候主要需要使用到如下的命令</p><ul><li>su : 切换到root</li></ul><ul><li>dmesg -c : 清除内核环缓存（kernel ring buffer）中的消息，这些消息通常由内核和系统的组件生成。使用该命令可以清除已经记录的消息，以便在控制台或日志中减少垃圾消息的显示。该命令通常在调试和故障排除期间使用，以便清除旧的消息，并在下一次记录消息时获得干净的环境</li></ul><ul><li>insmod: 向内核加载一个新的模块。它将指定的模块文件复制到内存中，并将其与内核中已经存在的代码进行连接。如果模块文件中的任何依赖项尚未加载，则insmod会自动加载它们。通过加载内核模块，可以向Linux内核添加新功能或驱动程序，而无需重新编译整个内核</li></ul><ul><li>rmmod: 从内核中卸载已经加载的模块。当不再需要一个模块时，可以使用该命令将其从内存中删除，以释放资源并减少内核的大小。如果正在使用该模块，则必须先停止使用该模块，然后才能将其卸载</li></ul><ul><li>lsmod: 列出当前已经加载的内核模块。可以通过查看lsmod输出中的模块列表来确定哪些模块可以使用rmmod卸载</li></ul><blockquote>以上命令都需要root权限</blockquote><pre><code class="language-bash">sudo su
make
dmesg -c # 删除其余信息
insmod hello.ko # 导入模块
dmesg
lsmod # 显示所有模块
# lsmod hello
rmmod hello.ko # 删除模块</code></pre></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/00-环境配置" >00-环境配置</a></li></ul><ul><li><a href="../../md-docs/01-module" >01-module</a></li></ul><ul><li><a href="../../md-docs/02-export" >02-export</a></li></ul><ul><li><a href="../../md-docs/03-params" >03-params</a></li></ul><ul><li><a href="../../md-docs/04-字符设备号" >04-字符设备号</a></li></ul><ul><li><a href="../../md-docs/05-字符设备架构" >05-字符设备架构</a></li></ul><ul><li><a href="../../md-docs/06-字符设备注册" >06-字符设备注册</a></li></ul><ul><li><a href="../../md-docs/07-自动创建设备节点" >07-自动创建设备节点</a></li></ul><ul><li><a href="../../md-docs/08-读写" >08-读写</a></li></ul><ul><li><a href="../../md-docs/PCI驱动" >PCI驱动</a></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank" >zood</a></div>
    <script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/00-环境配置","../../md-docs/02-export","ab")</script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>
</html>